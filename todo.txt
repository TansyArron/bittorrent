
DONE - write a simple socket!! :D

DOWNLOAD A FILE

DONE - 	write bencode
DONE - 	write decoder
DONE -	Decode and parse metainfo file 
DONE -	Form Get request (announce URL)
		To contact the tracker a peer MUST send a standard HTTP GET request using the URL in the "announce" entry of the metainfo file. The GET request must be parametrized as specified in the HTTP protocol. The following parameters must be present in the request:

DONE - 	FIX INFOHASH- Currently hard coding a working hash.
DONE -	Receive text file
DONE -	bdecode text file
DONE -	parse IP address of peer(s)
DONE -	Connect with seed (just one, to start)

DONE -	Handshake:
			20 bytes: ascii char 19 string "BitTorrent Protocol"
			8 bytes: for extensions. All 0's.
			20 bytes: SHA1 hash of bencoded info value in metafile. If both sides don't send the same they don't want to participate in the same swarm. 
			20 bytes: peer ID used to identifiy this client. If peer ID doesn't match expected ID, connection is severed. 

DONE -	Check returned handshake - match sha1 hash
	
	REFACTOR

DONE -	Create peer object:
			peer_ID 
			IP
			Port
			State (choke etc?)
			message handling
			create socket
			perform and check handshake
		 	parse bitfield or Have messages
			update peer.has

DONE -	Create torrent object:
			file size
			peers
			create new peer if peer form is {peerID:(IP, port)}
			peice size
			announce url
			hash list
			check file peices against hash
			write piece to file
			get next block
			update tracker info

DONE -	Create manager object:
			Initiate torrent object
			add/remove peers
			while torrent is unfinished:
				connect with available peers
				keep torrenting.

DONE-	manage pieces from multiple peers:
		what if pieces arrive out of order?
		how to choose next piece? 
		manage peer has useful pieces but not piece [0]

DONE- remove peers from managers connected list if:
			they have no useful pieces
			the connection fails

DONE- Make peer.listen() happen as peers connect. Currently all peers connect
	 asynchronously, and THEN peer.listen() happens. Maybe. 

	 	Optimize get_next_piece
	 	create torrent.have from half done torrent and re start



		SEED A FILE	

DONE - 	write bencode
		
		create bitfield from file/meta_info or use torrent.have
		create a file of infohash:(file path, metainfo)
		construct 'have' messages
		construct bitfield messages - from file or from torrent.have
		listen for peers
		respond to piece requests

	


CREATE A .TORRENT
	split file into chunks and identify chunks using Hashes.
	create info_dict
	bencode info_dict



